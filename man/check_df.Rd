% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/check_df.R
\name{check_df}
\alias{check_df}
\title{Check values in one or more columns of a data frame against a dictionary of
allowed values for each column}
\usage{
check_df(
  x = data.frame(),
  dictionary,
  col_vals = 1,
  col_vars = 2,
  return_allowed = FALSE,
  sep_allowed = "; ",
  nchar_allowed = 60
)
}
\arguments{
\item{x}{a data frame containing one or more variables (i.e. columns) whose
values are to be checked against a dictionary}

\item{dictionary}{a data frame with at least two columns, which define
variables within \code{x} and their corresponding set of allowed values.}

\item{col_vals}{name (character) or position (integer) of the column within
\code{dictionary} that represents allowed values. Defaults to \code{1} (first
column).}

\item{col_vars}{name (character) or position (integer) of the column within
\code{dictionary} that represents variables (or sets of variables matched with
a .regex keyword) in \code{x}. Defaults to \code{2} (second column).}

\item{return_allowed}{logical indicating whether the returned data frame
should include a third column summarizing the allowed values corresponding
to each non-allowed value/variable. The elements of this column are created
by collapsing the allowed values for the given variable into a single
string. Defaults to FALSE.}

\item{sep_allowed}{If \code{return_allowed == TRUE}, the \code{collapse} argument
passed to \code{paste()} for creating strings of allowed values from the
corresponding vectors. Defaults to "; ".}

\item{nchar_allowed}{If \code{return_allowed == TRUE}, the maximum number of
characters to return in strings defining allowed values. Longer strings are
truncated and given suffix "...". Defaults to \code{70} (set to \code{Inf} to avoid
truncation).}
}
\value{
A data frame of values in \code{x} that \strong{don't} match values in the
\code{dictionary}. Contains columns \code{value} and \code{variable}. If argument
\code{return_allowed == TRUE}, also contains a 3rd column \code{values_allowed} giving
the allowed values (collapsed into a string) for each variable.
}
\description{
Checks a data frame of raw data against a dictionary specifing allowed values
for one or more columns (or sets of columns matched with a regex keyword),
and returns a data frame listing the non-allowed values (if any) for each
column of interest. The returned data frame can form the basis for a second
dictionary to be used for recoding non-allowed values with \code{match_df} (e.g.
to correct misspellings, or otherwise standardize).
}
\section{Specifying columns of \code{x} in \code{dictionary[,col_vars]}}{


Elements within the \code{col_vars} column of \code{dictionary} represent keys that you
want to match to column names in \code{x} (the data set). These are expected to
match exactly with the exception of one reserved keyword that starts with a
full stop:
\itemize{
\item \code{.regex [pattern]}: any column whose name is matched by \verb{[pattern]}. The
\verb{[pattern]} should be an unquoted, valid, PERL-flavored regular expression.
}
}

\examples{

# Read in dictionaries and coded data examples --------------------

dict_allowed <- read.csv(matchmaker_example("allowed-dictionary.csv"),
  stringsAsFactors = FALSE)

dict_recode <- read.csv(matchmaker_example("spelling-dictionary.csv"),
  stringsAsFactors = FALSE)

dat <- read.csv(matchmaker_example("coded-data.csv"),
  stringsAsFactors = FALSE)

# check original data for non-allowed values
check_df(dat, dict_allowed)

# include column of allowed values in string format
check_df(dat, dict_allowed, return_allowed = TRUE)

# recode with match_df() then check for remaining non-allowed values
dat_recode <- match_df(dat,
  dictionary = dict_recode,
  from = "options",
  to = "values",
  by = "grp")

check_df(dat_recode, dict_allowed)

}
\author{
Patrick Barks
}
